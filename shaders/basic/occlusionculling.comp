#version 440 core

layout(local_size_x = 256, local_size_y = 1) in;

#include "common/bindings.glsl"
#include "common/camera.glsl"
#include "common/instances.glsl"
#include "common/meshes.glsl"

struct DrawElementsIndirectCommand
{
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

layout(std430, binding = INDIRECT_CMD_BINDING) restrict buffer CommandBlock
{
    DrawElementsIndirectCommand commands[];
};

layout(binding = 0) uniform sampler2D uDepthTex;
layout(location = 0) uniform uint uNumInstances;

// from OpenGL Insights
int get_lod(vec4 bounds)
{
    // first estimation
    vec2 view = vec2(textureSize(uDepthTex, 0));
    //vec2 area = bounds.zw - bounds.xy;
    //float square = dot(view, view) * dot(area, area);
    //float flod = ceil(0.5 * log2(square));
    vec2 viewSize = (bounds.zw - bounds.xy) * view;
    float flod = floor(log2(max(viewSize.x, viewSize.y) * 0.5));

    // move to the next level is that's not enough
    vec4 addr = floor(bounds * view.xyxy * exp2(-flod));
    vec2 diff = addr.zw - addr.xy;
    flod += step(2.0, max(diff.x, diff.y));

    return int(flod);
}

bool culling(in const uint ID)
{
    vec3 BBox[2] = vec3[2](instances[ID].bbox_min.xyz,
                           instances[ID].bbox_max.xyz);

    int numOutside[6] = int[6](0, 0, 0, 0, 0, 0);
    vec4 corner[8];
    for (uint i = 0; i < 8; ++i) {
        vec4 pos = vec4(BBox[(i>>0) & 0x01].x,
                        BBox[(i>>1) & 0x01].y,
                        BBox[(i>>2) & 0x01].z,
                        1.0);
        pos = pos * cam.ProjViewMatrix_T;
        if (pos.x < -pos.w)
            numOutside[0]++;
        if (pos.x >  pos.w)
            numOutside[1]++;
        if (pos.y < -pos.w)
            numOutside[2]++;
        if (pos.y >  pos.w)
            numOutside[3]++;
        if (pos.z < -pos.w)
            numOutside[4]++;
        if (pos.z >  pos.w)
            numOutside[5]++;
        corner[i] = pos;
    }

    // Frustum culling
    for (int i = 0; i < 6; ++i) {
        if (numOutside[i] == 8)
            return false;
    }

    vec3 pmin = vec3(1.0);
    vec3 pmax = vec3(0.0);
    for (int i = 0; i < 8; ++i) {
        vec3 tmp = clamp(corner[i].xyz, vec3(-corner[i].w), vec3(corner[i].w));
        tmp = (1.0 + tmp / corner[i].w) * 0.5;
        pmin = min(pmin, tmp);
        pmax = max(pmax, tmp);
    }


    vec4 bounds = vec4(pmin.xy, pmax.xy);
    int level = get_lod(bounds);

    const vec4 samples = vec4(
            textureLod(uDepthTex, bounds.xy, level).x,
            textureLod(uDepthTex, bounds.xw, level).x,
            textureLod(uDepthTex, bounds.zy, level).x,
            textureLod(uDepthTex, bounds.zw, level).x);
    const float ref_depth = max(max(samples[0], samples[1]), max(samples[2], samples[3]));

    return pmin.z <= ref_depth;
}

void main()
{
    const uint idx = gl_GlobalInvocationID.x;

    if (idx >= uNumInstances)
        return;

    const uint ID = commands[idx].baseInstance;

    const bool result = culling(ID);

    commands[idx].count = (result) ? meshes[instances[ID].meshID].count : 0;

    // bbox
    commands[idx + uNumInstances].count = (result) ? 24 : 0;

}
