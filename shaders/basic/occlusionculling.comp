#version 440 core

layout(local_size_x = 256, local_size_y = 1) in;

#include "common/camera.glsl"
#include "common/instances.glsl"
#include "common/meshes.glsl"

struct DrawElementsIndirectCommand
{
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

layout(std430, binding = 8) restrict writeonly buffer CommandBlock
{
    DrawElementsIndirectCommand commands[];
};

layout(std430, binding = 10) restrict writeonly buffer BBoxCommandBlock
{
    DrawElementsIndirectCommand bbox_commands[];
};

layout(std430, binding = 9) restrict readonly buffer InstanceIDBlock
{
    uint numInstances;
    uint instanceIDs[];
};

layout(binding = 0) uniform sampler2D depthTex;

void main()
{
    const uint idx = gl_GlobalInvocationID.x;

    if (idx < numInstances) {
        const uint ID = instanceIDs[idx];

        vec3 BBox[2] = vec3[2](instances[ID].bbox_min.xyz,
                               instances[ID].bbox_max.xyz);

        vec3 pmin = vec3(1.0);
        vec3 pmax = vec3(0.0);
        for (uint i = 0; i < 8; ++i) {
            vec4 pos = vec4(BBox[(i>>0) & 0x01].x,
                            BBox[(i>>1) & 0x01].y,
                            BBox[(i>>2) & 0x01].z,
                            1.0);
            pos = cam.ProjViewMatrix * pos;
            vec3 tmp = (pos.xyz / pos.w) * 0.5 + 0.5;
            pmin = min(pmin, tmp);
            pmax = max(pmax, tmp);
        }

        float ref_depth = pmin.z;
        if (all(greaterThanEqual(pmax, vec3(0.0))) &&
                all(lessThanEqual(pmin, vec3(1.0))))
        {
            vec4 bounds = vec4(max(pmin.xy, vec2(0.0)), min(pmax.xy, vec2(1.0)));

            // first estimation
            vec2 view = vec2(textureSize(depthTex, 0));
            //vec2 area = bounds.zw - bounds.xy;
            //float square = dot(view,view) * dot(area,area);
            //float flod = ceil(0.5 * log2(square)) - 1.0;

            float LOD = ceil(log2(max( ViewSizeX, ViewSizeY ))) - 1.0;

            // move to the next level, if that's not enough
            vec4 addr = floor(bounds * view.xyxy * exp2(-flod));
            //vec2 view_lod = vec2(textureSize(depthTex, int(flod)));
            //vec4 addr = floor(bounds * view_lod.xyxy);
            vec2 diff = addr.zw - addr.xy;
            flod += step(3.0, dot(diff,diff));
            int level = int(flod);

            //vec4 samples = vec4(
            //        textureLod(depthTex, bounds.xy, level).r,
            //        textureLod(depthTex, bounds.xw, level).r,
            //        textureLod(depthTex, bounds.zy, level).r,
            //        textureLod(depthTex, bounds.zw, level).r);
            ivec4 txl = ivec4(ivec2(bounds.xy * vec2(textureSize(depthTex, level))),
                              ivec2(bounds.zw * vec2(textureSize(depthTex, level))));
            vec4 samples = vec4(
                    texelFetch(depthTex, txl.xy, level).r,
                    texelFetch(depthTex, txl.xw, level).r,
                    texelFetch(depthTex, txl.zy, level).r,
                    texelFetch(depthTex, txl.zw, level).r);


            ref_depth = max(max(samples[0], samples[1]), max(samples[2], samples[3]));
            if (pmin.z < 0.0) {
                ref_depth = 1.0;
            }
        }

        commands[idx].count = (ref_depth > pmin.z) ? meshes[instances[ID].meshID].count : 0;
        commands[idx].instanceCount = 1;
        commands[idx].firstIndex = meshes[instances[ID].meshID].firstIndex;
        commands[idx].baseVertex = 0;
        commands[idx].baseInstance = ID;

        bbox_commands[idx].count = (ref_depth > pmin.z) ? 24 : 0;
        bbox_commands[idx].instanceCount = 1;
        bbox_commands[idx].firstIndex = 0;
        bbox_commands[idx].baseVertex = 0;
        bbox_commands[idx].baseInstance = ID;
    }

}
