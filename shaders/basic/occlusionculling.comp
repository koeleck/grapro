#version 440 core

layout(local_size_x = 256, local_size_y = 1) in;

#include "common/camera.glsl"
#include "common/instances.glsl"
#include "common/meshes.glsl"

struct DrawElementsIndirectCommand
{
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
};

layout(std430, binding = 8) restrict writeonly buffer CommandBlock
{
    DrawElementsIndirectCommand commands[];
};

layout(std430, binding = 10) restrict writeonly buffer BBoxCommandBlock
{
    DrawElementsIndirectCommand bbox_commands[];
};

layout(std430, binding = 9) restrict readonly buffer InstanceIDBlock
{
    uint numInstances;
    uint instanceIDs[];
};

layout(binding = 0) uniform sampler2D depthTex;

void main()
{
    const uint idx = gl_GlobalInvocationID.x;

    if (idx < numInstances) {
        const uint ID = instanceIDs[idx];

        vec3 BBox[2] = vec3[2](instances[ID].bbox_min.xyz,
                               instances[ID].bbox_max.xyz);

        int numOutside[6] = int[6](0, 0, 0, 0, 0, 0);
        vec4 corner[8];
        for (uint i = 0; i < 8; ++i) {
            vec4 pos = vec4(BBox[(i>>0) & 0x01].x,
                            BBox[(i>>1) & 0x01].y,
                            BBox[(i>>2) & 0x01].z,
                            1.0);
            pos = cam.ProjViewMatrix * pos;
            if (pos.x < -pos.w)
                numOutside[0]++;
            if (pos.x >  pos.w)
                numOutside[1]++;
            if (pos.y < -pos.w)
                numOutside[2]++;
            if (pos.y >  pos.w)
                numOutside[3]++;
            if (pos.z < -pos.w)
                numOutside[4]++;
            if (pos.z >  pos.w)
                numOutside[5]++;
            corner[i] = pos;
        }

        // Frustum culling
        for (int i = 0; i < 6; ++i) {
            if (numOutside[i] == 8)
                return;
        }

        vec3 pmin = vec3(2.0);
        vec3 pmax = vec3(-1.0);
        for (int i = 0; i < 8; ++i) {
            vec3 tmp = clamp(corner[i].xyz, vec3(-corner[i].w), vec3(corner[i].w));
            tmp = (tmp / corner[i].w) * 0.5 + 0.5;
            pmin = min(pmin, tmp);
            pmax = max(pmax, tmp);
        }


        // first estimation
        ivec4 addr = ivec4(vec4(pmin.xy, pmax.xy) * vec2(textureSize(depthTex, 0)).xyxy);
        ivec2 diff = addr.zw - addr.xy;
        int level = int(ceil(log2(max(diff.x, diff.y)))) - 1;
        addr >>= level;

        // move to the next level is that's not enough
        diff = addr.zw - addr.xy;
        addr >>= int(step(3u, max(diff.x, diff.y)));

        const vec4 samples = vec4(
                texelFetch(depthTex, addr.xy, level).r,
                texelFetch(depthTex, ivec2(addr.x, addr.w), level).r,
                texelFetch(depthTex, ivec2(addr.z, addr.y), level).r,
                texelFetch(depthTex, addr.zw, level).r);
        const float ref_depth = max(max(samples[0], samples[1]), max(samples[2], samples[3]));

        if (ref_depth < pmin.z)
            return;

        commands[idx].count = meshes[instances[ID].meshID].count;
        commands[idx].instanceCount = 1;
        commands[idx].firstIndex = meshes[instances[ID].meshID].firstIndex;
        commands[idx].baseVertex = 0;
        commands[idx].baseInstance = ID;

        bbox_commands[idx].count = 24;
        bbox_commands[idx].instanceCount = 1;
        bbox_commands[idx].firstIndex = 0;
        bbox_commands[idx].baseVertex = 0;
        bbox_commands[idx].baseInstance = ID;
    }

}
