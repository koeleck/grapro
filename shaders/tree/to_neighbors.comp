#version 440 core

#include "voxel.glsl"
#include "common/compression.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(location = 0) uniform uint uCount;
layout(location = 1) uniform uint uStartNode;
layout(location = 2) uniform int uNeighborIdx; // [0...5] (x-, x+, y-, y+, z-, z+)
layout(location = 3) uniform int uSide; // -1 or 1
layout(location = 4) uniform ivec3 uSwizzle;

void main()
{
    const uint threadId = gl_GlobalInvocationID.x;
    if (threadId >= uCount)
        return;

    const uint idx = uStartNode + threadId;

    uint neighbors[6] = uint[6](
            octreeInfo[idx].x_negative,
            octreeInfo[idx].x_positive,
            octreeInfo[idx].y_negative,
            octreeInfo[idx].y_positive,
            octreeInfo[idx].z_negative,
            octreeInfo[idx].z_positive);

    uint neighbor = neighbors[uNeighborIdx];
    if (neighbor == 0)
        return;

    bool isEmpty = (octree[idx].id & 0x80000000u) == 0;
    if (isEmpty && (octree[neighbor].id & 0x80000000u) == 0)
        return;

    ivec3 thisBrick = getBrickCoord(idx);
    ivec3 otherBrick = getBrickCoord(neighbor);

    bool readZero = isEmpty && (uSide > 0);
    for (int i = -1; i < 2; ++i) {
        for (int j = -1; j < 2; ++j) {
            ivec3 c0;
            c0[uSwizzle.x] = i;
            c0[uSwizzle.y] = j;
            c0[uSwizzle.z] = uSide;

            ivec3 c1 = c0;
            c1[uSwizzle.z] = -uSide;

            vec4 val = readZero ? vec4(0.0) : imageLoad(octreeBrickTex, thisBrick + c0);
            if (uSide < 0) {
                val *= 0.5;
                imageStore(octreeBrickTex, thisBrick + c0, val);
            } else {
                val += imageLoad(octreeBrickTex, otherBrick + c1);
            }
            imageStore(octreeBrickTex, otherBrick + c1, val);
        }
    }
}
