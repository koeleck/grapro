#version 440 core

#include "common/extensions.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

#include "common/bindings.glsl"
#include "voxel.glsl"
#include "common/compression.glsl"

layout(location = 0) uniform uint uNumVoxelFrag;
layout(location = 1) uniform uint uTreeLevels;
layout(location = 2) uniform uint uMaxLevel;
layout(location = 3) uniform uint uNumVoxelsPerDim;
layout(location = 4) uniform vec3 uSceneBoundingBox[2];

void main()
{
    // retrieve current thread id and return if out of bounds
    const uint ID = gl_GlobalInvocationID.x;
    if (ID >= uNumVoxelFrag)
        return;

    uint voxel_dim = uNumVoxelsPerDim;
    uvec3 umin = uvec3(0u);
    uvec3 pos = unpackUInt3x10(voxelFragment[ID].position_xyz);

    // index of first child
    uint childidx = 0u;
    uint nodeptr = octree[childidx].id;

    // iterate through all tree levels
    for (uint i = 0u; i < uMaxLevel; ++i) {
        voxel_dim /= 2u;

        // find subnode
        uvec3 subnode = clamp((pos - umin) / voxel_dim, uvec3(0u), uvec3(1u));

        // get child pointer by ignoring the node's ptr MSB
        childidx = uint(nodeptr & 0x7FFFFFFFu);
        // determine index of subnode
        childidx += subnode.z * 4u + subnode.y * 2u + subnode.x;

        umin += voxel_dim * subnode;

        nodeptr = octree[childidx].id;
    }

    // flag node
    octree[childidx].id = 0x80000000u;

    if (uMaxLevel + 1 == uTreeLevels) {

        // unpack stuff
        vec4 tmp = unpackUnorm4x8(voxelFragment[ID].diff_rgb_normal_x);
        vec3 diffuse = tmp.xyz;

        vec3 normal;
        normal.x = tmp.w;
        tmp = unpackUnorm4x8(voxelFragment[ID].normal_yz_emissive_rg);
        normal.yz = tmp.xy;
        normal = (normal * 2.0) - 1.0;

        vec3 emissive;
        emissive.rg = tmp.zw;
        tmp = unpackUnorm4x8(voxelFragment[ID].emissive_b);
        emissive.b = tmp.x;

        // set worldspace position
        octreeColor[childidx].position = uSceneBoundingBox[0] +
            (vec3(pos) + 0.5) / float(uNumVoxelsPerDim) * (uSceneBoundingBox[1] - uSceneBoundingBox[0]);

        // add
        atomicAdd(octreeColor[childidx].count, 1);

        atomicAdd(octreeColor[childidx].diffuse.r, diffuse.r);
        atomicAdd(octreeColor[childidx].diffuse.g, diffuse.g);
        atomicAdd(octreeColor[childidx].diffuse.b, diffuse.b);

        atomicAdd(octreeColor[childidx].emissive.r, emissive.r);
        atomicAdd(octreeColor[childidx].emissive.g, emissive.g);
        atomicAdd(octreeColor[childidx].emissive.b, emissive.b);

        atomicAdd(octreeColor[childidx].normal.x, normal.x);
        atomicAdd(octreeColor[childidx].normal.y, normal.y);
        atomicAdd(octreeColor[childidx].normal.z, normal.z);

    }

}
