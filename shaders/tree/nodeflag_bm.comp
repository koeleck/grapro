#version 440 core

#include "common/bindings.glsl"
#include "common/voxel.glsl"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// voxel buffer
struct voxelStruct {
    uvec4 position;
    vec4 color;
    vec4 normal;
};

layout (std430, binding = VOXEL_BINDING) restrict readonly buffer voxelBlock {
    voxelStruct voxel[];
};

uniform uint u_numVoxelFrag;
uniform uint u_voxelDim;
uniform uint u_maxLevel;

void main()
{
    // retrieve current thread id and return if out of bounds
    uint threadId = gl_GlobalInvocationID.y * gl_NumWorkGroups.x * gl_WorkGroupSize.x + gl_GlobalInvocationID.x;
    if (threadId >= u_numVoxelFrag)
        return;

    // local vars
    uint childidx = 0;

    uint nodeptr = octree[childidx].id; // root address

    int voxel_dim = int(u_voxelDim);
    bool has_to_be_flagged = true;

    ivec3 umin = ivec3(0);

    ivec3 pos = ivec3(voxel[threadId].position.xyz);

    // iterate through all tree levels
    for (uint i = 0; i < u_maxLevel; ++i) {

        // go to next dimension
        voxel_dim /= 2;

        // check if the current node is flagged
        // IS IT EVER NOT FLAGGED????
        if ((nodeptr & 0x80000000) == 0) {
            // node is not flagged
            has_to_be_flagged = false;
            break;
        }

        // get child pointer by ignoring the node's ptr MSB
        childidx = uint(nodeptr & 0x7FFFFFFF);

        // create subnodes
        ivec3 subnodeptrXYZ = clamp(ivec3(1 + pos - umin - voxel_dim), 0, 1);

        int subnodeptr = subnodeptrXYZ.x;
        subnodeptr += 2 * subnodeptrXYZ.y;
        subnodeptr += 4 * subnodeptrXYZ.z;

        childidx += subnodeptr;

        umin.x += voxel_dim * subnodeptrXYZ.x;
        umin.y += voxel_dim * subnodeptrXYZ.y;
        umin.z += voxel_dim * subnodeptrXYZ.z;

        // update node
        nodeptr = octree[childidx].id;
    }

    // first iteration will skip the for-loop above!
    // check if current node has to be set "flagged"
    if (has_to_be_flagged) {
        // set the flag. if the flag is set the node is marked that it has to be checked for
        // further subdivisions (it has no childs so far)
        nodeptr |= 0x80000000;
        octree[childidx].id = nodeptr;
    }

}
