#version 440 core

#include "common/extensions.glsl"
#include "common/bindings.glsl"
#include "common/voxel.glsl"

layout (local_size_variable) in;

uniform uint u_numVoxelFrag;
uniform uint u_voxelDim;
uniform uint u_maxLevel;
uniform uint u_isLeaf;

void main()
{
    // retrieve current thread id and return if out of bounds
    const uint threadID = gl_GlobalInvocationID.x;
    if (threadID >= u_numVoxelFrag)
        return;

    uint childIdx = 0;
    uint nodePtr = octree[0].id; // ptr to first child
    int voxelDim = int(u_voxelDim);
    ivec3 umin = ivec3(0);
    const ivec3 pos = ivec3(convertPosition(voxel[threadID].position));

    // iterate through all tree levels
    for (uint i = 0; i < u_maxLevel; ++i) {
        iterateTreeLevel(pos, nodePtr, voxelDim, childIdx, umin);
    }

    // flag node
    octree[childIdx].id = 0x80000000u;

    // store color if it's a leaf
    if (u_isLeaf == 1) {
        const vec3 col = convertColor(voxel[threadID].color);
        const vec3 normal = unpackUnorm4x8(voxel[threadID].normal).xyz;
        atomicAdd(octreeColor[childIdx].color.r, col.r);
        atomicAdd(octreeColor[childIdx].color.g, col.g);
        atomicAdd(octreeColor[childIdx].color.b, col.b);
        atomicAdd(octreeColor[childIdx].color.a, 1.f);
        atomicAdd(octreeColor[childIdx].normal.x, normal.x);
        atomicAdd(octreeColor[childIdx].normal.y, normal.y);
        atomicAdd(octreeColor[childIdx].normal.z, normal.z);
        atomicAdd(octreeColor[childIdx].normal.w, 1.f);
    }

}
