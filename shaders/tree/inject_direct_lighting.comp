#version 440 core

#include "common/extensions.glsl"
#include "common/lights.glsl"
#include "common/textures.glsl"
#include "voxel.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(location = 0) uniform uint uCount;
layout(location = 1) uniform uint uStartNode;
layout(location = 2) uniform bool u_shadowsEnabled;

float get2DShadow(in const mat4 ProjViewMatrix_T,
        in const float fovFactor,
        in const vec3 lightDir,
        in const vec3 toLight,
        in const vec3 diff,
        in const vec3 normal,
        in const vec4 wpos,
        in const int layer)
{
    // normal offset
    float shadowMapTexelSize = 2.0 / textureSize(uShadowMapTex, 0).x;

    // scale normal offset by shadow depth
    shadowMapTexelSize *= abs(dot(diff, lightDir)) * fovFactor;

    float cosLightAngle = abs(dot(toLight, normal));

    float normalOffsetScale = clamp(1.0 - cosLightAngle, 0.0, 1.0);
    const float shadowNormalOffset = 50.0; // TODO
    normalOffsetScale *= shadowNormalOffset * shadowMapTexelSize;
    vec4 shadowOffset = vec4(normal * normalOffsetScale, 0.0);

    // only uv offset
    vec4 lP = wpos * ProjViewMatrix_T;
    vec4 lUVOffsetP = (wpos + shadowOffset) * ProjViewMatrix_T;
    lP.xy = lUVOffsetP.xy;

    // slope scale
    float sinLightAngle = sqrt(1.0 - cosLightAngle*cosLightAngle);
    float slope = sinLightAngle / max(cosLightAngle, 0.00001);
    const float slopeScaleBias = 0.09; // TODO
    float shadowBias = 0.09; // TODO
    shadowBias += slope * slopeScaleBias;
    lP.z -= shadowBias;

    lP.xyz = (lP.xyz / lP.w) * 0.5 + 0.5;

    vec4 texcoord = vec4(lP.xy, float(layer), lP.z);

    // PCF:
    return  (
                textureOffset(uShadowMapTex, texcoord, ivec2(-1, -1)) +
                textureOffset(uShadowMapTex, texcoord, ivec2( 0, -1)) +
                textureOffset(uShadowMapTex, texcoord, ivec2( 1, -1)) +
                textureOffset(uShadowMapTex, texcoord, ivec2(-1,  0)) +
                textureOffset(uShadowMapTex, texcoord, ivec2( 0,  0)) +
                textureOffset(uShadowMapTex, texcoord, ivec2( 1,  0)) +
                textureOffset(uShadowMapTex, texcoord, ivec2(-1,  1)) +
                textureOffset(uShadowMapTex, texcoord, ivec2( 0,  1)) +
                textureOffset(uShadowMapTex, texcoord, ivec2( 1,  1))
            ) / 9.0;
}

float get3DShadow(in const vec3 lightPos,
        in const float fovFactor,
        in const vec2 depthFactor,
        in const vec3 toLight,
        in const vec3 diff,
        in const vec3 normal,
        in vec3 wpos,
        in const int layer)
{
    // normal offset
    float shadowMapTexelSize = 2.0 / textureSize(uShadowCubeMapTex, 0).x;

    // scale normal offset by shadow depth
    shadowMapTexelSize *= length(diff) * fovFactor;

    float cosLightAngle = dot(toLight, normal);

    float normalOffsetScale = clamp(1.0 - cosLightAngle, 0.0, 1.0);
    const float shadowNormalOffset = 10.0; // TODO
    normalOffsetScale *= shadowNormalOffset * shadowMapTexelSize;
    vec3 shadowOffset = normal * normalOffsetScale;
    wpos += shadowOffset;

    // slope scale
    float sinLightAngle = sqrt(1.0 - cosLightAngle*cosLightAngle);
    float slope = sinLightAngle / max(cosLightAngle, 0.00001);
    const float cubeSlopeScaleBias = 0.5; // TODO
    float cubeShadowBias = 50.19; // TODO
    cubeShadowBias += slope * cubeSlopeScaleBias;

    wpos += toLight * cubeShadowBias;

    vec3 absDiff = abs(diff);
    const float abs_z = max(absDiff.x, max(absDiff.y, absDiff.z));
    // see lights.cpp for depthFactor
    const float depth = depthFactor.x + depthFactor.y / abs_z;


    vec3 dir = wpos - lightPos;

    // hack: find perpendicular vector
    vec3 offDir0 = 2.0 * shadowMapTexelSize * normalize(cross(dir, vec3(0.0, 0.0, 1.0)));
    vec3 offDir1 = 2.0 * shadowMapTexelSize * normalize(cross(dir, offDir0));

    //vec4 texcoord = vec4(dir, layer);
    //return texture(uShadowCubeMapTex, texcoord, depth);
    return
        (
            texture(uShadowCubeMapTex, vec4(dir - offDir0 - offDir1, layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir           - offDir1, layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir + offDir0 - offDir1, layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir - offDir0          , layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir                    , layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir + offDir0          , layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir - offDir0 - offDir1, layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir           - offDir1, layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir + offDir0 - offDir1, layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir - offDir0 + offDir1, layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir           + offDir1, layer), depth) +
            texture(uShadowCubeMapTex, vec4(dir + offDir0 + offDir1, layer), depth)
        ) / 9.0;
}

vec3 computeRadiance(in vec4 wpos, in vec3 normal)
{
    vec3 result = vec3(0.0);

    for (int i = 0; i < numLights; ++i) {
        float attenuation;
        vec3 light_dir;
        const int type_texid = lights[i].type_texid;
        const bool isShadowcasting = u_shadowsEnabled &&
            ((type_texid & LIGHT_IS_SHADOWCASTING) != 0);

        // TODO max dist
        if ((type_texid & LIGHT_TYPE_DIRECTIONAL) != 0) {
            light_dir = -lights[i].direction;
            attenuation = 1.0;
            if (isShadowcasting) {
                int layer = (type_texid & LIGHT_TEXID_BITS);
                attenuation *= get2DShadow(lights[i].ProjViewMatrix_T,
                        lights[i].fovFactor,
                        lights[i].direction,
                        light_dir,
                        light_dir,
                        normal,
                        wpos,
                        layer);
            }
        } else if ((type_texid & LIGHT_TYPE_SPOT) != 0) {
            const vec3 diff = wpos.xyz - lights[i].position;
            const float dist = length(diff);
            const vec3 dir = diff / dist;

            light_dir = -dir;
            attenuation = smoothstep(lights[i].angleOuterCone, lights[i].angleInnerCone,
                    dot(dir, lights[i].direction)) /
                    (lights[i].constantAttenuation + lights[i].linearAttenuation * dist +
                     lights[i].quadraticAttenuation * dist * dist);
            if (isShadowcasting) {
                int layer = (type_texid & LIGHT_TEXID_BITS);
                attenuation *= get2DShadow(lights[i].ProjViewMatrix_T,
                        lights[i].fovFactor,
                        lights[i].direction,
                        light_dir,
                        diff,
                        normal,
                        wpos,
                        layer);
            }
        } else { // POINT
            const vec3 diff = wpos.xyz - lights[i].position;
            const float dist = length(diff);
            const vec3 dir = diff / dist;
            light_dir = -dir;
            attenuation = 1.0 /
                    (lights[i].constantAttenuation + lights[i].linearAttenuation * dist +
                     lights[i].quadraticAttenuation * dist * dist);
            if (isShadowcasting) {
                int layer = (type_texid & LIGHT_TEXID_BITS);
                attenuation *= get3DShadow(lights[i].position,
                        lights[i].fovFactor,
                        lights[i].direction.xy, // see lights.cpp why
                        light_dir,
                        diff,
                        normal,
                        wpos.xyz,
                        layer);
            }
        }

        const float n_dot_l = max(dot(light_dir, normal), 0.0);


        result += attenuation * lights[i].intensity * n_dot_l;
    }
    return result;
}

void main()
{
    const uint threadId = gl_GlobalInvocationID.x;
    if (threadId >= uCount)
        return;

    const uint idx = uStartNode + threadId;
    if ((octree[idx].id & 0x80000000u) == 0)
        return;

    const vec3 pos = octreeInfo[idx].position.xyz;
    const uint count = octreeInfo[idx].count;
    const vec3 normal = normalize(octreeInfo[idx].normal.xyz);
    const vec3 col = octreeInfo[idx].diffuse.rgb / count;
    const vec3 emi = octreeInfo[idx].emissive.rgb / count;

    vec4 result = vec4(emi + col * computeRadiance(vec4(pos, 1.0), normal), 1.0);
    ivec3 texcoord = getBrickCoord(idx);
    for (int z = -1; z < 2; ++z) {
        for (int y = -1; y < 2; ++y) {
            for (int x = -1; x < 2; ++x) {
                imageStore(octreeBrickTex, texcoord + ivec3(x, y, z), result);
            }
        }
    }


}
