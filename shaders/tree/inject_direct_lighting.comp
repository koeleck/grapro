#version 440 core

#include "common/extensions.glsl"
#include "common/lights.glsl"
#include "common/textures.glsl"
#include "voxel.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(location = 0) uniform uint uCount;
layout(location = 1) uniform uint uStartNode;
layout(location = 2) uniform uint u_shadowsEnabled;

vec3 computeRadiance(in vec3 pos, in vec3 normal)
{
    vec3 result = vec3(0.0);

    for (int i = 0; i < numLights; ++i) {
        float attenuation;
        vec3 light_dir;
        const int type_texid = lights[i].type_texid;
        const bool isShadowcasting = (type_texid & LIGHT_IS_SHADOWCASTING) != 0 && u_shadowsEnabled != 0;

        // TODO max dist
        if ((type_texid & LIGHT_TYPE_DIRECTIONAL) != 0) {
            light_dir = -lights[i].direction;
            attenuation = 1.0;
            if (isShadowcasting) {
                int layer = (type_texid & LIGHT_TEXID_BITS);
                vec4 tmp = vec4(pos, 1.0) * lights[i].ProjViewMatrix_T;
                tmp.xyz = (tmp.xyz / tmp.w) * 0.5 + 0.5;
                vec4 texcoord = vec4(tmp.xy, float(layer), tmp.z);
                //attenuation *= texture(uShadowMapTex, texcoord);
                // PCF:
                attenuation *= (textureOffset(uShadowMapTex, texcoord, ivec2(-2, -2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 0, -2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 2, -2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2(-2,  0)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 0,  0)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 2,  0)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2(-2,  2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 0,  2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 2,  2))) / 9.0;
            }
        } else if ((type_texid & LIGHT_TYPE_SPOT) != 0) {
            const vec3 diff = pos - lights[i].position;
            const float dist = length(diff);
            const vec3 dir = diff / dist;

            light_dir = -dir;
            attenuation = smoothstep(lights[i].angleOuterCone, lights[i].angleInnerCone,
                    dot(dir, lights[i].direction)) /
                    (lights[i].constantAttenuation + lights[i].linearAttenuation * dist +
                     lights[i].quadraticAttenuation * dist * dist);
            if (isShadowcasting) {
                // normal offset
                float normalOffsetScale = 1.0 - max(dot(light_dir, normal), 0.0);
                vec3 normalOffset = normal * 50.0 * normalOffsetScale;

                int layer = (type_texid & LIGHT_TEXID_BITS);

                vec4 tmp = vec4(pos, 1.0) * lights[i].ProjViewMatrix_T;
                tmp.xyz = (tmp.xyz / tmp.w) * 0.5 + 0.5;

                vec4 tmp2 = vec4(pos + normalOffset, 1.0) * lights[i].ProjViewMatrix_T;
                tmp.xy = (tmp2.xy / tmp2.w) * 0.5 + 0.5;

                vec4 texcoord = vec4(tmp.xy, float(layer), tmp.z);
                //attenuation *= texture(uShadowMapTex, texcoord);
                // PCF:
                attenuation *= (textureOffset(uShadowMapTex, texcoord, ivec2(-2, -2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 0, -2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 2, -2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2(-2,  0)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 0,  0)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 2,  0)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2(-2,  2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 0,  2)) +
                                textureOffset(uShadowMapTex, texcoord, ivec2( 2,  2))) / 9.0;
            }
        } else { // POINT
            const vec3 diff = pos - lights[i].position;
            const float dist = length(diff);
            const vec3 dir = diff / dist;
            light_dir = -dir;
            attenuation = 1.0 /
                    (lights[i].constantAttenuation + lights[i].linearAttenuation * dist +
                     lights[i].quadraticAttenuation * dist * dist);
            if (isShadowcasting) {
                int layer = (type_texid & LIGHT_TEXID_BITS);
                vec3 absDiff = abs(diff);
                const float abs_z = max(absDiff.x, max(absDiff.y, absDiff.z));
                const float f = 2000.0; const float n = 1.0;
                // see src/core/light.cpp:
                const float depth = lights[i].direction.x + lights[i].direction.y / abs_z;

                vec4 texcoord = vec4(dir, layer);
                attenuation *= texture(uShadowCubeMapTex, texcoord, depth);
            }
        }

        const float n_dot_l = max(dot(light_dir, normal), 0.0);

        result += attenuation * lights[i].intensity * n_dot_l;
    }
    return result;
}

void main()
{
    const uint threadId = gl_GlobalInvocationID.x;
    if (threadId >= uCount)
        return;

    const uint idx = uStartNode + threadId;
    if ((octree[idx].id & 0x80000000u) == 0)
        return;

    const vec3 pos = octreeInfo[idx].position.xyz;
    const uint count = octreeInfo[idx].count;
    const vec3 normal = normalize(octreeInfo[idx].normal.xyz);
    const vec3 col = octreeInfo[idx].diffuse.rgb / count;
    const vec3 emi = octreeInfo[idx].emissive.rgb / count;

    vec4 result = vec4(emi + col * computeRadiance(pos, normal), 1.0);
    ivec3 texcoord = getBrickCoord(idx);
    for (int z = -1; z < 2; ++z) {
        for (int y = -1; y < 2; ++y) {
            for (int x = -1; x < 2; ++x) {
                imageStore(octreeBrickTex, texcoord + ivec3(x, y, z), result);
            }
        }
    }


}
