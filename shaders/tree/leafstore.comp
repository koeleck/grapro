#version 440 core

#include "common/extensions.glsl"
#include "common/bindings.glsl"
#include "common/voxel.glsl"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// voxel buffer
struct voxelStruct {
    uvec4 position;
    vec4 color;
    vec4 normal;
};

layout (std430, binding = VOXEL_BINDING) restrict readonly buffer voxelBlock {
    voxelStruct voxel[];
};

uniform uint u_numVoxelFrag;
uniform uint u_treeLevels;
uniform uint u_voxelDim;

// atomic running average method
// from open insights chapter 22
vec4 convRGBA8ToVec4(in uint val)
{
    return vec4(float((val&0x000000FF)), float((val&0x0000FF00) >> 8U),
                float((val&0x00FF0000) >> 16U), float((val&0xFF000000) >> 24U));
}

uint convVec4ToRGBA8(in vec4 val)
{
    return (uint(val.w) & 0x000000FF) << 24U | (uint(val.z) & 0x000000FF) << 16U
            | (uint(val.y) & 0x000000FF) << 8U | (uint(val.x) & 0x000000FF);
}

/*void atomicAvg(vec4 newColor_Vec4, uint idx)
{

    newColor_Vec4.rgb *= 255.0;
    newColor_Vec4.a = 1;
    uint newColor_UInt = convVec4ToRGBA8(newColor_Vec4);
    uint compareColor_UInt = 0;
    uint currentColor_UInt = 0;

    while((currentColor_UInt = atomicCompSwap(octreeColor[idx].color, compareColor_UInt, newColor_UInt))
           != compareColor_UInt) {

        compareColor_UInt = currentColor_UInt;

        vec4 currentColor_Vec4 = convRGBA8ToVec4(currentColor_UInt);
        // currentColor_Vec4.w is the number of colors already averaged in currentColor
        currentColor_Vec4.xyz = currentColor_Vec4.xyz * currentColor_Vec4.w;

        currentColor_Vec4 += newColor_Vec4;
        currentColor_Vec4.xyz /= currentColor_Vec4.w;

        newColor_UInt = convVec4ToRGBA8(currentColor_Vec4);

    }

}*/

// https://www.opengl.org/registry/specs/NV/shader_atomic_float.txt
void atomicAvgFloat(vec4 newColor, uint idx)
{

    // color has to be divided by w in future uses!
    atomicAdd(octreeColor[idx].color.x, newColor.x);
    atomicAdd(octreeColor[idx].color.y, newColor.y);
    atomicAdd(octreeColor[idx].color.z, newColor.z);
    atomicAdd(octreeColor[idx].color.w, 1);

}

void main()
{
    // retrieve current thread id and return if out of bounds
    uint threadId = gl_GlobalInvocationID.y * 1024 + gl_GlobalInvocationID.x;
    if (threadId >= u_numVoxelFrag)
        return;

    ivec3 pos = ivec3(voxel[threadId].position.xyz);
    vec4 col = voxel[threadId].color;

    // local vars
    uint childIdx = 0;
    uint nodePtr = octree[childIdx].id;

    uint voxelDim = u_voxelDim;

    uvec3 umin = uvec3(0);

    // iterate through all tree levels
    for (uint i = 0; i < u_treeLevels - 1; ++i) {

        // go to next dimension
        voxelDim /= 2;

        // mask out flag bit to get child idx
        childIdx = int(nodePtr & 0x7FFFFFFF);

        // create subnodes
        ivec3 subnodeptrXYZ = clamp(ivec3(1 + pos - umin - voxelDim), 0, 1);

        int subnodeptr = subnodeptrXYZ.x;
        subnodeptr += 2 * subnodeptrXYZ.y;
        subnodeptr += 4 * subnodeptrXYZ.z;

        childIdx += subnodeptr;

        umin.x += voxelDim * subnodeptrXYZ.x;
        umin.y += voxelDim * subnodeptrXYZ.y;
        umin.z += voxelDim * subnodeptrXYZ.z;

        // update node
        nodePtr = octree[childIdx].id;
    }

    //atomicAvg(col, childIdx);
    atomicAvgFloat(col, childIdx);

}
