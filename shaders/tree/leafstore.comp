#version 440 core

#include "common/extensions.glsl"
#include "common/bindings.glsl"
#include "common/voxel.glsl"

layout (local_size_variable) in;

uniform uint u_numVoxelFrag;
uniform uint u_treeLevels;
uniform uint u_voxelDim;

void main()
{
    // retrieve current thread id and return if out of bounds
    const uint threadID = gl_GlobalInvocationID.x;
    if (threadID >= u_numVoxelFrag)
        return;

    uint childIdx = 0;
    uint nodePtr = octree[0].id; // ptr to first child
    int voxelDim = int(u_voxelDim);
    ivec3 umin = ivec3(0);
    const ivec3 pos = ivec3(voxel[threadID].position.xyz);
    const vec4 col = voxel[threadID].color;

    // iterate through all tree levels
    for (uint i = 0; i < u_treeLevels - 1; ++i) {

        // calculate lower level dimension
        voxelDim /= 2;

        // get child pointer by ignoring the node's ptr MSB
        childIdx = int(nodePtr & 0x7FFFFFFF);

        // create subnodes
        const ivec3 subnode = clamp(1 + pos - umin - voxelDim, 0, 1);
        umin += voxelDim * subnode;

        // calculate new child node
        childIdx += subnode.x + 2 * subnode.y + 4 * subnode.z;
        nodePtr = octree[childIdx].id;

    }

    atomicAdd(octreeColor[childIdx].color.x, col.x);
    atomicAdd(octreeColor[childIdx].color.y, col.y);
    atomicAdd(octreeColor[childIdx].color.z, col.z);

    // color has to be divided by w in future uses!
    atomicAdd(octreeColor[childIdx].color.w, 1);

}
