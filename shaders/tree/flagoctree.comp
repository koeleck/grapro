#version 440 core

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout (std430, binding = VOXEL_BINDING) buffer voxelBlock {
	voxelStruct voxel[];
};

uniform int u_num_voxels;
uinform int u_tree_level;
uniform int u_voxel_dim;

void main()
{
	// retrieve current thread id and return if out of bounds
	const uint grid = 1024;
	uint threadId = gl_GlobalInvocationID.y * grid + gl_GlobalInvocationID.x;
	if(threadId >= u_num_voxels) 
		return;

	// local vars
	uint nodeptr  = voxel[childptr].color.r;
	uint childptr = 0;

	bool flagged = true;

	// iterate through all tree levels
	for(uint i = 0; i < u_tree_level; ++i) {

		// go to next dimension
		u_voxel_dim /= 2;

		// check if the current node is flagged
		if(!(nodeptr & 0x80000000)) {
			// node is not flagged
			flagged = false;
		}

		// get child pointer by ignoring the node's ptr MSB
		childptr = uint(nodeptr & 0x7f000000);

		// create subnodes 
		// ...

		// update node
		nodeptr = voxel[childptr].color.r;
	}

	// check if current node has to be set "flagged"
	if(flagged) {
		nodeptr |= 0x80000000;
		voxel[childptr].color.r = nodeptr;
	}
}
