#version 440 core

#include "common/bindings.glsl"

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// voxel buffer
struct voxelStruct {
	uvec4 position;
	vec4 color;
	vec4 normal;
};

layout (std430, binding = VOXEL_BINDING) buffer voxelBlock {
	voxelStruct voxel[];
};

// octree buffer
struct octreeBuffer {
	uint id;
};

layout (std430, binding = OCTREE_BINDING) buffer octreeBlock {
	octreeBuffer octree[];
};

uniform int u_numVoxelFrag;
uniform int u_tree_level;

void main()
{
	// retrieve current thread id and return if out of bounds
	const uint grid = 1024;
	uint threadId = gl_GlobalInvocationID.y * grid + gl_GlobalInvocationID.x;
	if(threadId >= u_numVoxelFrag)
		return;

	// local vars
	uint childidx = 0;

	uint nodeptr = octree[childidx].id;
	uint subnodeptr = 0;

	uint voxel_dim = uint(pow(2, u_tree_level));
	bool flagged = true;

	uvec3 umin = uvec3(0);
	uvec3 umax = uvec3(voxel_dim);

	uvec4 pos  = voxel[threadId].position;

	// iterate through all tree levels
	for(uint i = 0; i < u_tree_level; ++i) {

		// go to next dimension
		voxel_dim /= 2;

		// check if the current node is flagged
		if((nodeptr & 0x80000000) == 0) {
			// node is not flagged
			flagged = false;
		}

		// get child pointer by ignoring the node's ptr MSB
		childidx = uint(nodeptr & 0x7f000000);

		// create subnodes
		subnodeptr = clamp(uint(1 + pos.x - umin.x - voxel_dim), 0, 1);
		subnodeptr += 4 * clamp(uint(1 + pos.y - umin.y - voxel_dim), 0, 1);
		subnodeptr += 2 * clamp(uint(1 + pos.z - umin.z - voxel_dim), 0, 1);

		childidx += uint(subnodeptr);

		umin.x += voxel_dim * clamp(uint(1 + pos.x - umin.x - voxel_dim), 0, 1);
		umin.y += voxel_dim * clamp(uint(1 + pos.y - umin.y - voxel_dim), 0, 1);
		umin.z += voxel_dim * clamp(uint(1 + pos.z - umin.z - voxel_dim), 0, 1);

		// update node
		nodeptr = octree[childidx].id;
	}

	// check if current node has to be set "flagged"
	if(flagged) {
		nodeptr |= 0x80000000;
		octree[childidx].id = nodeptr;
	}
}
