#version 440 core

#include "voxel.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(location = 0) uniform uint uCount;
layout(location = 1) uniform uint uStartNode;

void main()
{
    const uint threadId = gl_GlobalInvocationID.x;
    if (threadId >= uCount)
        return;

    const uint idx = uStartNode + threadId;
    if ((octree[idx].id & 0x80000000u) == 0)
        return;

    const uint childidx = (octree[idx].id & 0x7fffffffu);

    ivec3 brick[8];

    /*
     * gaussian weights for cube:
     *   - corner:          1/64  (8 points)
     *   - edge:            1/32  (12 points)
     *   - side midpoint:   1/16  (6 points)
     *   - center:          1/8   (1 point)
     */

    /*
    vec4 result = vec4(0.0);
    float count = 0.0;
    for (int i = 0; i < 8; ++i) {
        bool isEmpty = ((octree[childidx + i].id & 0x80000000u) == 0);
        brick[i] = getBrickCoord(childidx + i);

        // read value at child center
        if (!isEmpty) {
            count += 1.0;
            result += imageLoad(octreeBrickTex, brick[i]);
        }
    }
    //result.rgb /= (count * 8.0);
    result.rgb /= 32.0; // 64.0
    result.a = 1.0;


    // edges
    result.rgb += (imageLoad(octreeBrickTex, brick[0] + ivec3(1, 0, 0)).rgb +
                   imageLoad(octreeBrickTex, brick[0] + ivec3(0, 1, 0)).rgb +
                   imageLoad(octreeBrickTex, brick[0] + ivec3(0, 0, 1)).rgb +
                   imageLoad(octreeBrickTex, brick[1] + ivec3(0, 1, 0)).rgb +
                   imageLoad(octreeBrickTex, brick[1] + ivec3(0, 0, 1)).rgb +
                   imageLoad(octreeBrickTex, brick[2] + ivec3(1, 0, 0)).rgb +
                   imageLoad(octreeBrickTex, brick[2] + ivec3(0, 0, 1)).rgb +
                   imageLoad(octreeBrickTex, brick[3] + ivec3(0, 0, 1)).rgb +
                   imageLoad(octreeBrickTex, brick[4] + ivec3(1, 0, 0)).rgb +
                   imageLoad(octreeBrickTex, brick[4] + ivec3(0, 0, 1)).rgb +
                   imageLoad(octreeBrickTex, brick[5] + ivec3(0, 1, 0)).rgb +
                   imageLoad(octreeBrickTex, brick[6] + ivec3(1, 0, 0)).rgb) / 16.0; // 32.0;

    // side midpoints
    result.rgb += (imageLoad(octreeBrickTex, brick[0] + ivec3( 1,  1,  0)).rgb +
                   imageLoad(octreeBrickTex, brick[0] + ivec3( 0,  1,  1)).rgb +
                   imageLoad(octreeBrickTex, brick[0] + ivec3( 1,  0,  1)).rgb +
                   imageLoad(octreeBrickTex, brick[7] + ivec3(-1,  0, -1)).rgb +
                   imageLoad(octreeBrickTex, brick[7] + ivec3(-1, -1,  0)).rgb +
                   imageLoad(octreeBrickTex, brick[7] + ivec3( 0, -1, -1)).rgb) / 8.0; // 16.0;

    // center:
    result.rgb += imageLoad(octreeBrickTex, brick[0] + ivec3(1)).rgb / 4.0; // 8.0;

    */

    vec4 result = vec4(0.0);
    float count = 0.0;
    for (int i = 0; i < 8; ++i) {
        bool isEmpty = ((octree[childidx + i].id & 0x80000000u) == 0);
        ivec3 brick = getBrickCoord(childidx + i);

        // read value at child center
        if (!isEmpty) {
            count += 1.0;
            result += imageLoad(octreeBrickTex, brick);
        }
    }
    //result.rgb /= count;
    //result.a /= 8.0;
    result /= 8.0;

    ivec3 thisBrick = getBrickCoord(idx);
    //imageStore(octreeBrickTex, thisBrick, result);
    for (int z = -1; z < 2; ++z) {
        for (int y = -1; y < 2; ++y) {
            for (int x = -1; x < 2; ++x) {
                imageStore(octreeBrickTex, thisBrick + ivec3(x, y, z), result);
            }
        }
    }

}
