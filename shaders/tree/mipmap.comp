#version 440 core

#include "voxel.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(location = 0) uniform uint uCount;
layout(location = 1) uniform uint uStartNode;

void main()
{
    const uint threadId = gl_GlobalInvocationID.x;
    if (threadId >= uCount)
        return;

    const uint idx = uStartNode + threadId;
    if ((octree[idx].id & 0x80000000u) == 0)
        return;

    const uint childidx = (octree[idx].id & 0x7fffffffu);


    /*
     * gaussian weights for cube:
     *   - corner:          1/64  (8 points)
     *   - edge:            1/32  (12 points)
     *   - side midpoint:   1/16  (6 points)
     *   - center:          1/8   (1 point)
     */

    ivec3 thisBrick = getBrickCoord(idx);
    ivec3 brick[8];
    vec4 result = vec4(0.0);
    for (int i = 0; i < 8; ++i) {
        brick[i] = getBrickCoord(childidx + i);
        result += sampleBrick(brick[i], ivec3(0), true);
        //result += imageLoad(octreeBrickTex, brick[i]);
    }
    result /= 4.0;

    /*
    for (int z = -1; z < 2; ++z) {
        for (int y = -1; y < 2; ++y) {
            for (int x = -1; x < 2; ++x) {
                vec4 result = vec4(0.0);
                ivec3 pos = ivec3(x, y, z);
                bool mask[8];
                mask[0] = (pos.x == -1 || pos.x == 0) &&
                          (pos.y == -1 || pos.y == 0) &&
                          (pos.z == -1 || pos.z == 0);
                mask[1] = (pos.x ==  0 || pos.x == 1) &&
                          (pos.y == -1 || pos.y == 0) &&
                          (pos.z == -1 || pos.z == 0);
                mask[2] = (pos.x == -1 || pos.x == 0) &&
                          (pos.y ==  0 || pos.y == 1) &&
                          (pos.z == -1 || pos.z == 0);
                mask[3] = (pos.x ==  0 || pos.x == 1) &&
                          (pos.y ==  0 || pos.y == 1) &&
                          (pos.z == -1 || pos.z == 0);
                mask[4] = (pos.x == -1 || pos.x == 0) &&
                          (pos.y == -1 || pos.y == 0) &&
                          (pos.z ==  0 || pos.z == 1);
                mask[5] = (pos.x ==  0 || pos.x == 1) &&
                          (pos.y == -1 || pos.y == 0) &&
                          (pos.z ==  0 || pos.z == 1);
                mask[6] = (pos.x == -1 || pos.x == 0) &&
                          (pos.y ==  0 || pos.y == 1) &&
                          (pos.z ==  0 || pos.z == 1);
                mask[7] = (pos.x ==  0 || pos.x == 1) &&
                          (pos.y ==  0 || pos.y == 1) &&
                          (pos.z ==  0 || pos.z == 1);
                for (int i = 0; i < 8; ++i) {
                    if (mask[i] == false)
                        continue;
                    result += sampleBrick(brick[i], pos, false);
                }

                imageStore(octreeBrickTex, thisBrick + pos, result);
            }
        }
    }
    */

    for (int z = -1; z < 2; ++z) {
        for (int y = -1; y < 2; ++y) {
            for (int x = -1; x < 2; ++x) {
                imageStore(octreeBrickTex, thisBrick + ivec3(x, y, z), result);
            }
        }
    }

}
