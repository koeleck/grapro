#version 440 core

#include "voxel.glsl"

layout (local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(location = 0) uniform uint uCount;
layout(location = 1) uniform uint uStartNode;

void main()
{
    const uint threadId = gl_GlobalInvocationID.x;
    if (threadId >= uCount)
        return;

    const uint idx = uStartNode + threadId;
    if ((octree[idx].id & 0x80000000u) == 0)
        return;

    /*
    ivec3 thisBrick = getBrickCoord(idx);
    for (int z = -1; z < 2; ++z) {
        for (int y = -1; y < 2; ++y) {
            for (int x = -1; x < 2; ++x) {
                imageStore(octreeBrickTex, thisBrick + ivec3(x, y, z), vec4(1.0));
            }
        }
    }
    return;
    */

    const uint childidx = (octree[idx].id & 0x7fffffffu);

    ivec3 brick[8];
    vec4 result = vec4(0.0);

    /*
     * gaussian weights for cube:
     *   - corner:          1/64  (8 points)
     *   - edge:            1/32  (12 points)
     *   - side midpoint:   1/16  (6 points)
     *   - center:          1/8   (1 point)
     */

    for (int i = 0; i < 8; ++i) {
        bool isEmpty = ((octree[childidx + i].id & 0x80000000u) == 0);
        brick[i] = getBrickCoord(childidx + i);

        // read value at child center
        if (!isEmpty)
            result += imageLoad(octreeBrickTex, brick[i]);
    }
    //result /= 64.0; // gaussian weight for cube corners


    /*
    // edges
    result += (imageLoad(octreeBrickTex, brick[0] + ivec3(1, 0, 0)) +
               imageLoad(octreeBrickTex, brick[0] + ivec3(0, 1, 0)) +
               imageLoad(octreeBrickTex, brick[0] + ivec3(0, 0, 1)) +
               imageLoad(octreeBrickTex, brick[1] + ivec3(0, 1, 0)) +
               imageLoad(octreeBrickTex, brick[1] + ivec3(0, 0, 1)) +
               imageLoad(octreeBrickTex, brick[2] + ivec3(1, 0, 0)) +
               imageLoad(octreeBrickTex, brick[2] + ivec3(0, 0, 1)) +
               imageLoad(octreeBrickTex, brick[3] + ivec3(0, 0, 1)) +
               imageLoad(octreeBrickTex, brick[4] + ivec3(1, 0, 0)) +
               imageLoad(octreeBrickTex, brick[4] + ivec3(0, 0, 1)) +
               imageLoad(octreeBrickTex, brick[5] + ivec3(0, 1, 0)) +
               imageLoad(octreeBrickTex, brick[6] + ivec3(1, 0, 0))) / 32.0;

    // side midpoints
    result += (imageLoad(octreeBrickTex, brick[0] + ivec3(1, 1, 0)) +
               imageLoad(octreeBrickTex, brick[0] + ivec3(0, 1, 1)) +
               imageLoad(octreeBrickTex, brick[0] + ivec3(1, 0, 1)) +
               imageLoad(octreeBrickTex, brick[7] + ivec3(-1, 0, -1)) +
               imageLoad(octreeBrickTex, brick[7] + ivec3(-1, -1, 0)) +
               imageLoad(octreeBrickTex, brick[7] + ivec3(0, -1, -1))) / 16.0;

    // center:
    result += imageLoad(octreeBrickTex, brick[0] + ivec3(1)) / 8.0;
    */

    ivec3 thisBrick = getBrickCoord(idx);
    for (int z = -1; z < 2; ++z) {
        for (int y = -1; y < 2; ++y) {
            for (int x = -1; x < 2; ++x) {
                imageStore(octreeBrickTex, thisBrick + ivec3(x, y, z), result);
            }
        }
    }
}
